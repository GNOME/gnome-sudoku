# GUI to Sudoku
from gettext import gettext as _
import gtk, sudoku, math, gobject, cairo
import pango, random
from simple_debug import simple_debug

entry_color = "#fff"
ro_color = "#ddd"

NO_NOTES_TO_NOTES_RATIO = 2.125

class ParallelDict (dict):
    """A handy new sort of dictionary for tracking conflicts.

    pd = ParallelDict()
    pd[1] = [2,3,4] # 1 is linked with 2,3 and 4
    pd -> {1:[2,3,4],2:[1],3:[1],4:[1]}
    pd[2] = [1,3,4] # 2 is linked with 3 and 4 as well as 1
    pd -> {1: [2,3,4],2:[3,4],3:[1,2],4:[1,2]}
    Now for the cool part...
    del pd[1]
    pd -> {2: [2,3],3:[2],4:[2]}
    
    Pretty neat, no?
    """
    def __init__ (self, *args):
        dict.__init__(self,*args)

    def __setitem__ (self, k, v):
        dict.__setitem__(self,k,set(v))
        for i in v:
            if i == k: continue
            if self.has_key(i):
                self[i].add(k)
            else:
                dict.__setitem__(self,i,set([k]))
            
    def __delitem__ (self, k):
        v=self[k]
        dict.__delitem__(self,k)
        for i in v:
            if i==k: continue
            if k in self[i]: self[i].remove(k)
            if not self[i]:
                dict.__delitem__(self,i)

class Fonts:
    read_only_font = pango.FontDescription()
    read_only_font.set_weight(pango.WEIGHT_ULTRABOLD)
    read_only_font.set_size(int(pango.SCALE * 9.25))
    read_only_color = "#333"
    normal_font = pango.FontDescription()
    normal_font.set_weight(pango.WEIGHT_NORMAL)
    normal_font.set_size(int(pango.SCALE * 9.25))
    error_color = "#FF0000"
    normal_color = "#000"
    colors = ["#%02x%02x%02x"%(r,b,g) for r,b,g in [(0,0,255), #blue
                                                    (0,255,0), # green
                                                    (255,0,255),#purple
                                                    (255,128,0),#orange
                                                    #(0,255,128),#turquoise-ish
                                                    (128,0,255),#dark purple
                                                    (128,128,128),#grey
                                                    (165,25,25),#maroon-ish
                                                    (0,128,0), #dark green
                                                    (0,0,128), #dark blue
                                                    (139,105,20),#muddy
                                                    ]
              ]

def change_font_size (size):
    size = int(size)
    Fonts.normal_font.set_size(size)
    Fonts.read_only_font.set_size(size)

class NumberEntry (gtk.Entry):
    conversions = {10:'A',
                   11:'B',
                   12:'C',
                   13:'D',
                   14:'E',
                   15:'F',
                   16:'G',
                   }
    def __init__ (self, upper=9, base_color=(entry_color,ro_color)):
        self.color = None
        self.base_color = base_color[0]
        self.base_color_RO = base_color[1]
        self.read_only=False
        gtk.Entry.__init__(self)
        if base_color:
            self.modify_base_color(base_color)
        for k,v in self.conversions.items(): self.conversions[v]=k        
        self.upper = upper
        self.set_width_chars(2)
        self.set_alignment(0.5)
        self.set_max_length(1)
        self.modify_font(Fonts.normal_font)
        self.__internal_change__ = False
        self.connect('focus-out-event',self.focus_out_cb)
        self.connect('key-press-event',self.keypress_cb)
        self.connect('changed',self.changed_cb)
        self.unset_color()
        self.show()

    def modify_base_color (self, base_color):
        if base_color==None:
            base_color = (None,None)
        self.base_color,self.base_color_RO = base_color
        if type(self.base_color)==str:
            self.base_color=gtk.gdk.color_parse(self.base_color)
        if type(self.base_color_RO)==str:
            self.base_color_RO=gtk.gdk.color_parse(self.base_color_RO)
        else:
            self.base_color_RO=self.get_style().base[gtk.STATE_INSENSITIVE]
        if self.read_only:
            self.modify_bg(gtk.STATE_NORMAL,self.base_color_RO)
            self.modify_base(gtk.STATE_NORMAL,self.base_color_RO)
            self.modify_fg(gtk.STATE_NORMAL,self.base_color_RO)
        else:
            self.modify_bg(gtk.STATE_NORMAL,self.base_color)
            self.modify_base(gtk.STATE_NORMAL,self.base_color)
            self.modify_fg(gtk.STATE_NORMAL,self.base_color) 

    def changed_cb (self, *args):
        if self.__internal_change__:
            self.emit_stop_by_name('changed')
            return True

    def set_read_only (self, val):
        self.set_editable(not val)
        self.read_only = val
        print self,'.read_only=',self.x,self.y,self.read_only
        if val:
            self.modify_font(Fonts.read_only_font)
            self.modify_base_color((self.base_color,self.base_color_RO))
            if not self.color: self._set_color_(Fonts.read_only_color)
        else:
            self.modify_font(Fonts.normal_font)
            self.modify_base_color((self.base_color,self.base_color_RO))
            if not self.color: self._set_color_(Fonts.normal_color)

    def _set_color_ (self, color):
        color = self.get_colormap().alloc_color(color)
        self.modify_text(gtk.STATE_NORMAL,color)
        self.modify_text(gtk.STATE_INSENSITIVE,color)

    @simple_debug
    def set_color (self, color):
        self.color = color
        self._set_color_(color)

    def unset_color (self):
        self.color = None
        if hasattr(self,'x'): print self,'.unset_color',self.x,self.y,
        if self.read_only:
            print 'unset_color->read_only_color'
            self._set_color_(Fonts.read_only_color)
        else:
            print 'unset_color->normal_color'            
            self._set_color_(Fonts.normal_color)

    def set_error_highlight (self, val):
        print self,'.set_error_highlight->',val,
        if val:
            print '(use _set_color_)'
            self._set_color_(Fonts.error_color)
            #self.set_sensitive(True)
        else:
            #if self.read_only: self.set_sensitive(False)
            if self.color and (not self.read_only):
                print '(use _set_color_ to orig color)'
                self._set_color_(self.color)
            else:
                print '(use unset_color)'
                self.unset_color()

    def set_value (self, val):
        try: self.x,self.y
        except: pass
        if val > self.upper:
            raise ValueError("Too large a number!")
        if val >= 10:
            self.__internal_change__ = True
            self.set_text(self.conversions[val])
            self.__internal_change__ = False
        else:
            self.__internal_change__ = True
            if val: self.set_text(str(val))
            else: self.set_text("")
            self.__internal_change__ = False            
            
    def get_value (self):
        txt = self.get_text()
        if self.conversions.has_key(txt.capitalize()):
            val = self.conversions[txt.capitalize()]
        else:
            try:
                val = int(txt)
            except:
                val = None
        if val > self.upper:
            self.set_text("")
            raise ValueError("Too large a number!")
        return val

    def set_impossible (self, val):
        if val:
            try:
                self.__internal_change__=True
                self.set_text('X')
                self.__internal_change__=False
            except: pass
        else:
            if self.get_text()=='X':
                self.__internal_change__=True
                self.set_text('')
                self.__internal_change__=False
        self.impossible = val
        self.set_error_highlight(val)

    def focus_out_cb (self, widget, event):
        widget.select_region(0,0)

    def keypress_cb (self, widget, event):
        name = gtk.gdk.keyval_name(event.keyval)
        parent = widget.get_parent()
        while parent and not isinstance(parent,gtk.Window) :
            parent = parent.get_parent()
        if name in ['Left','KP_Left']:
            parent.emit('move-focus',gtk.DIR_LEFT)
            return True
        elif name in ['Right','KP_Right']:
            parent.emit('move-focus',gtk.DIR_RIGHT)
            return True

BORDER_WIDTH = 5.0
BORDER_LINE_WIDTH = 2
BASE_SIZE = 35

class SudokuNumberEntry (gtk.Widget):

    text = ''
    read_only = False
    _layout = None
    _note_layout = None
    text_color = None
    highlight_color = None

    __gsignals__ = {
        'changed':(gobject.SIGNAL_RUN_LAST,gobject.TYPE_NONE,()),
        }
    
    def __init__ (self, upper=9, base_color=(entry_color,ro_color), text=''):
        gtk.Widget.__init__(self)
        self.modify_base_color(base_color)
        self.set_property('can-focus',True)
        self.set_property('events',gtk.gdk.ALL_EVENTS_MASK)
        self.connect('button-press-event',self.button_press_cb)
        self.connect('key-release-event',self.key_press_cb)
        self.set_text(text)

    def modify_base_color (self, base_color):
        ec = gtk.gdk.color_parse(base_color[0])
        self.entry_color = (ec.red-1)/2**16,(ec.green-1)/2**16,(ec.blue-1)/2**16
        rc = gtk.gdk.color_parse(base_color[1])
        self.ro_color = (rc.red-1.0)/2**16,(rc.green-1.0)/2**16,(rc.blue-1.0)/2**16

    def button_press_cb (self, w, e):
        print 'button press!'
        self.grab_focus()

    def key_press_cb (self, w, e):
        txt = gtk.gdk.keyval_name(e.keyval)
        if txt in [str(n) for n in range(1,10)]:
            print 'set_text(%s)'%txt
            self.set_text_interactive(txt)

    def set_text_interactive (self,text):
        self.set_text(text)
        self.queue_draw()
        self.emit('changed')

    def set_text (self, text):
        self.text = text
        self._layout = self.create_pango_layout(text)
        self._layout.set_font_description(pango.FontDescription("Sans Serif 12"))

    def set_note_text (self, text):
        self._note_layout = self.create_pango_layout(text)
        self._note_layout.set_font_description(pango.FontDescription("Sans Serif 6"))

    def do_realize (self):
        # The do_realize method is responsible for creating GDK (windowing system)
        # resources. In this example we will create a new gdk.Window which we
        # then draw on

        # First set an internal flag telling that we're realized
        self.set_flags(self.flags() | gtk.REALIZED)

        # Create a new gdk.Window which we can draw on.
        # Also say that we want to receive exposure events by setting
        # the event_mask
        self.window = gtk.gdk.Window(
            self.get_parent_window(),
            width=self.allocation.width,
            height=self.allocation.height,
            window_type=gtk.gdk.WINDOW_CHILD,
            wclass=gtk.gdk.INPUT_OUTPUT,
            event_mask=self.get_events() | gtk.gdk.EXPOSURE_MASK)

        # Associate the gdk.Window with ourselves, Gtk+ needs a reference
        # between the widget and the gdk window
        self.window.set_user_data(self)

        # Attach the style to the gdk.Window, a style contains colors and
        # GC contextes used for drawing
        self.style.attach(self.window)

        # The default color of the background should be what
        # the style (theme engine) tells us.
        self.style.set_background(self.window, gtk.STATE_NORMAL)
        self.window.move_resize(*self.allocation)

    def do_unrealize (self):
        # The do_unrealized method is responsible for freeing the GDK resources

        # De-associate the window we created in do_realize with ourselves
        self.window.set_user_data(None)

    def do_size_request (self, requisition):
        # The do_size_request method Gtk+ is calling on a widget to ask
        # it the widget how large it wishes to be. It's not guaranteed
        # that gtk+ will actually give this size to the widget

        # In this case, we say that we want to be as big as the
        # text is, plus a little border around it.
        width, height = self._layout.get_size()
        #print 'width/height = ',width,height,width/pango.SCALE,height/pango.SCALE
        requisition.width = (width / pango.SCALE)+(BORDER_LINE_WIDTH+BORDER_WIDTH)*2
        requisition.height = height / pango.SCALE+(BORDER_LINE_WIDTH+BORDER_WIDTH)*2

    def do_size_allocate(self, allocation):
        # The do_size_allocate is called by when the actual size is known
        # and the widget is told how much space could actually be allocated

        # Save the allocated space
        self.allocation = allocation
        
        # If we're realized, move and resize the window to the
        # requested coordinates/positions
        if self.flags() & gtk.REALIZED:
            self.window.move_resize(*allocation)

    def do_expose_event(self, event):
        # The do_expose_event is called when the widget is asked to draw itself
        # Remember that this will be called a lot of times, so it's usually
        # a good idea to write this code as optimized as it can be, don't
        # Create any resources in here.
        x, y, w, h = self.allocation
        cr = self.window.cairo_create()
        if h<w:
            scale = h/float(BASE_SIZE)
            #print 'scale = ',scale
        else:
            scale = w/float(BASE_SIZE)
        cr.scale(scale,scale)

        # Draw background color
        if self.read_only:
            cr.set_source_rgb(*self.ro_color)
        else:
            cr.set_source_rgb(*self.entry_color)
        cr.rectangle(
            0,0,BASE_SIZE,BASE_SIZE
            )
        cr.fill()

        cr.set_source_rgb(1.0,.75,0.25)
        if self.is_focus():
            if w > h:
                side = h
            else:
                side = w
            cr.rectangle(
                # left-top
                BORDER_LINE_WIDTH,
                BORDER_LINE_WIDTH,
                # bottom-right
                BASE_SIZE-(2*BORDER_LINE_WIDTH),
                BASE_SIZE-(2*BORDER_LINE_WIDTH),
                )
            cr.set_line_width(BORDER_LINE_WIDTH)
            cr.set_line_join(cairo.LINE_JOIN_MITER)
            cr.stroke()

        if self.highlight_color:
            cr.set_source_rgb(*self.highlight_color)
        elif self.text_color:
            cr.set_source_rgb(*self.text_color)
        else:
            cr.set_source_color(self.style.fg[self.state])        
        # And draw the text in the middle of the allocated space
        if self._layout:
            fontw, fonth = self._layout.get_pixel_size()
            cr.move_to(
                (BASE_SIZE/2)-(fontw/2),
                (BASE_SIZE/2) - (fonth/2),
                )
            cr.update_layout(self._layout)
            cr.show_layout(self._layout)

        cr.set_source_color(self.style.fg[self.state])        
        # And draw any note text...
        if self._note_layout:
            fontw, fonth = self._note_layout.get_pixel_size()
            cr.move_to(
                0+BORDER_LINE_WIDTH+BORDER_WIDTH,
                0,
                )
            cr.update_layout(self._note_layout)
            cr.show_layout(self._note_layout)

    def hide_notes (self):
        pass

    def show_notes (self):
        pass

    def set_value (self,v):
        self.set_text(str(v))

    def get_value (self):
        try: return int(self.text)
        except: return None

    def get_text (self): return self.text

    def set_error_highlight (self, val):
        if val:
            self.highlight_color = (1.0,0,0)
        else:
            self.highlight_color = None

    def set_read_only (self, val): self.read_only = val

    def set_color (self, color):
        self.text_color = color

gobject.type_register(SudokuNumberEntry)
SuperNumberEntry = SudokuNumberEntry

from SuperEntry import SuperEntry
class SuperNumberEntryOld (SuperEntry,NumberEntry):

    # Attributes for which we just provide a proxy to main_entry's
    # attribute
    pass_through_attnames = ['x','y','read_only']

    def __init__ (self,*args,**kwargs):
        self.args,self.kwargs = args,kwargs
        SuperEntry.__init__(self)
        self.connect = self.main_entry.connect
        self.set_text = self.main_entry.set_text
        self.get_text = self.main_entry.get_text
        self.set_value = self.main_entry.set_value
        self.get_value = self.main_entry.get_value
        self.set_error_highlight = self.main_entry.set_error_highlight
        self.set_read_only = self.main_entry.set_read_only
        self.set_color = self.main_entry.set_color
        self._set_color_ = self.main_entry._set_color_
        #self.modify_font = self.main_entry.modify_font

    def __setattr__ (self, attr, val):
        print '__setattr__',self,attr,val
        if attr in pass_through_attnames:
            print 'pass through to main attrs setattr',attr,val
            return setattr(self.main_entry,attr,val)
        else:
            return SuperEntry.__setattr__(self,attr,val)

    def __getattr__ (self, attr):
        if attr in self.pass_through_attnames:
            print "getting main_entry's",attr
            return getattr(self.main_entry,attr)
        else:
            try:
                return SuperEntry.__getattr__(self,attr)
            except:
                raise AttributeError, attr
        
    def hide_notes (self):
        self.top_entry.hide()
        self.sub_entry.hide()
        self.main_entry.set_width_chars(2)
        self.main_entry.set_has_frame(True)

    def show_notes (self):
        self.top_entry.show()
        self.sub_entry.show()
        self.main_entry.set_width_chars(4)
        self.main_entry.set_has_frame(False)        

    def setup_main_entry (self):
        self.main_entry = NumberEntry(*self.args,**self.kwargs)
        self.main_entry.set_width_chars(4)
        self.main_entry.set_alignment(0.5)
        self.main_entry.set_max_length(1)        

    def __setattr__ (self, attname, val):
        if attname=='x': self.main_entry.x = val
        elif attname=='y': self.main_entry.y = val
        SuperEntry.__setattr__(self,attname,val)
        
class EntryGrid (gtk.Table):
    
    def __init__ (self, group_size=9,entry_color=(entry_color,ro_color)):
        gtk.Table.__init__(self,rows=group_size,columns=group_size,homogeneous=True,
                           )
        self.group_size = group_size
        self.change_spacing(3)
        self.__entries__ = {}
        for x in range(self.group_size):
            for y in range(self.group_size):
                e = SuperNumberEntry(upper=self.group_size,base_color=entry_color)
                e.x = x
                e.y = y
                self.attach(e,x,x+1,y,y+1,
                            xoptions=gtk.FILL,
                            yoptions=gtk.FILL,
                            xpadding=0,
                            ypadding=0)
                self.__entries__[(x,y)]=e
        self.show_all()
        self.showing_notes = True

    def get_focused_entry (self):
        for e in self.__entries__.values():
            if e.is_focus():
                return e
            else:
                if True in [ec.is_focus() for ec in e.get_children()]:
                    return e

    def get_font_size (self, size=None):
        return
        size = Fonts.normal_font.get_size() or (pango.SCALE * 18)
        return size

    def change_font_size (self, size=None, multiplier=None):
        return
        if not size and not multiplier:
            raise "No size given you dumbass"
        elif multiplier:
            size = multiplier * (Fonts.normal_font.get_size() or (pango.SCALE * 12))
        change_font_size(size)
        for e in self.__entries__.values():
            if e.read_only: e.modify_font(Fonts.read_only_font)
            else: e.modify_font(Fonts.normal_font)
        pt_size = (size/pango.SCALE)
        spacer_size = pt_size / 4
        if spacer_size < 1: spacer_size = 1
        spacer_size = int(spacer_size)
        if self.showing_notes:
            spacer_size = int(spacer_size * NO_NOTES_TO_NOTES_RATIO)
        self.change_spacing(spacer_size)

    def change_spacing (self, small_spacing):
        self.small_spacing = small_spacing
        self.big_spacing = small_spacing*3
        self.set_row_spacings(small_spacing)
        self.set_col_spacings(small_spacing)
        box_side = int(math.sqrt(self.group_size))
        for n in range(1,box_side):
            self.set_row_spacing(box_side*n-1,self.big_spacing)
            self.set_col_spacing(box_side*n-1,self.big_spacing)

    def show_notes (self):
        if self.showing_notes: return
        self.showing_notes = True
        self.change_font_size(multiplier=float(1/NO_NOTES_TO_NOTES_RATIO))
        for e in self.__entries__.values(): e.show_notes()

    def hide_notes (self):
        if not self.showing_notes: return
        self.showing_notes = False
        self.change_font_size(multiplier=NO_NOTES_TO_NOTES_RATIO)
        for e in self.__entries__.values(): e.hide_notes()

class SudokuGridDisplay (EntryGrid, gobject.GObject):

    __gsignals__ = {
        'puzzle-finished':(gobject.SIGNAL_RUN_LAST,gobject.TYPE_NONE,())
        }
    
    @simple_debug
    def __init__ (self,grid=None,group_size=9,
                  show_impossible_implications=False):
        group_size=int(group_size)
        self.hints = 0
        self.auto_fills = 0
        self.show_impossible_implications = show_impossible_implications
        self.impossible_hints = 0
        self.impossibilities = []
        self.trackers = {}
        self.__trackers_tracking__ = {}
        self.__colors_used__ = [Fonts.error_color, Fonts.normal_color]
        gobject.GObject.__init__(self)
        EntryGrid.__init__(self,group_size=group_size)
        self.setup_grid(grid,group_size)
        for e in self.__entries__.values():
            e.show()
            e.connect('changed',self.entry_callback)
            e.connect('focus-in-event',self.focus_callback)
            #e.connect('clicked',self.focus_callback)

    @simple_debug
    def focus_callback (self, e, event):
        if hasattr(self,'hint_in_label') and self.hint_in_label: self.hint_in_label.set_text('')
        self.focused = e
        if hasattr(self,'label'):
            self.show_hint(self.label)

    @simple_debug
    def show_hint (self, label):
        self.hints += 1
        self.hint_in_label = label
        entry = self.focused
        if entry.read_only:
            label.set_text('')
        else:
            vals=self.grid.possible_values(entry.x,entry.y)
            vals = list(vals)
            vals.sort()
            if vals:
                label.set_text(_("Possible values ") + ",".join(self.num_to_str(v) for v in vals))
            elif not entry.get_text():
                label.set_text(_("No values are possible!"))
            else:
                label.set_text("")

    @simple_debug
    def num_to_str (self, n):
        if n >= 10: return SuperNumberEntry.conversions[n]
        else: return str(n)

    @simple_debug
    def reset_grid (self):
        """Reset grid to its original setup.

        Return a list of items we removed so that callers can handle
        e.g. Undo properly"""
        removed = []
        for x in range(self.group_size):
            for y in range(self.group_size):
                if not self.grid.virgin._get_(x,y):
                    val = self.grid._get_(x,y)
                    if val:
                        removed.append((x,y,val,self.trackers_for_point(x,y,val)))
                        self.remove(x,y)
                        self.grid.remove(x,y)
        return removed
    
    @simple_debug
    def blank_grid (self):
        for x in range(self.group_size):
            for y in range(self.group_size):
                self.remove(x,y)                
                e=self.__entries__[(x,y)]
                e.set_read_only(False)                
        self.grid = None

    @simple_debug
    def change_grid (self, grid, group_size):
        self.blank_grid()
        self.setup_grid(grid,group_size)
        self.auto_fills = 0
        self.hints = 0
        self.impossible_hints = 0
        self.trackers = {}
        self.__trackers_tracking__ = {}
        self.__colors_used__ = [Fonts.error_color, Fonts.normal_color]

    @simple_debug
    def load_game (self, game):
        """Load a game.

        A game is simply a two lined string where the first line represents our
        virgin self and line two represents our game-in-progress.
        """
        self.blank_grid()
        virgin,in_prog = game.split('\n')
        group_size=int(math.sqrt(len(virgin.split())))
        self.change_grid(virgin,group_size=group_size)
        # This int() will break if we go to 16x16 grids...
        values = [int(c) for c in in_prog.split()]
        for row in range(group_size):
            for col in range(group_size):
                index = row * 9 + col
                if values[index] and not self.grid._get_(col,row):
                    self.add(col,row,values[index])

    @simple_debug
    def setup_grid (self, grid, group_size):
        self.doing_initial_setup = True
        self.__error_pairs__ = ParallelDict()
        if isinstance(grid,sudoku.SudokuGrid):
            self.grid = sudoku.InteractiveSudoku(grid.grid,group_size=grid.group_size)
        else:
            self.grid = sudoku.InteractiveSudoku(grid,group_size=group_size)
        for x in range(group_size):
            for y in range(group_size):
                val=self.grid._get_(x,y)
                if val: self.add(x,y,val)
        self.doing_initial_setup = False

    @simple_debug
    def entry_callback (self, widget, *args):
        if not widget.get_text():
            if self.grid and self.grid._get_(widget.x,widget.y):
                self.grid.remove(widget.x,widget.y)
            self.remove(widget.x,widget.y)
        else:
            self.entry_validate(widget)
        if self.show_impossible_implications:
            self.mark_impossible_implications(widget.x,widget.y)

    @simple_debug
    def entry_validate (self, widget, *args):
        val = widget.get_value()
        try:
            self.add(widget.x,widget.y,val)
            if self.grid.check_for_completeness():
                self.emit('puzzle-finished')
        except sudoku.ConflictError, err:
            conflicts=[self.grid.find_conflict(err.x,err.y,err.value,err.type)]
            # We check for more than one conflict...  We count on the
            # order conflicts are checked for in our initial script in
            # sudoku.py -- ROW then COLUMN then BOX
            if err.type==sudoku.TYPE_ROW:
                if err.value in self.grid.cols[err.x]:
                    conflicts.append(self.grid.find_conflict(err.x,err.y,err.value,sudoku.TYPE_COLUMN))
            if err.type in [sudoku.TYPE_COLUMN,sudoku.TYPE_ROW]:
                if err.value in self.grid.boxes[self.grid.box_by_coords[(err.x,err.y)]]:
                    conflicts.append(self.grid.find_conflict(err.x,err.y,err.value,sudoku.TYPE_BOX))
            for conflict in conflicts:
                widget.set_error_highlight(True)
                self.__entries__[conflict].set_error_highlight(True)
            self.__error_pairs__[(err.x,err.y)]=conflicts

    @simple_debug
    def add (self, x, y, val, trackers=[]):
        """Add value val at position x,y.

        If tracker is True, we track it with tracker ID tracker.

        Otherwise, we use any currently tracking trackers to track our addition.

        Providing the tracker arg is mostly useful for e.g. undo/redo
        or removed items.

        To specify NO trackers, use trackers=[-1]
        """
        self.__entries__[(x,y)].set_value(val)
        if self.doing_initial_setup:
            self.__entries__[(x,y)].set_read_only(True)
        self.grid.add(x,y,val,True)
        if trackers:
            for tracker in trackers:
                if tracker==-1: pass
                self.__entries__[(x,y)].set_color(self.get_tracker_color(tracker))
                self.trackers[tracker].append((x,y,val))
        elif True in self.__trackers_tracking__.values():        
            for k,v in self.__trackers_tracking__.items():
                if v:
                    self.__entries__[(x,y)].set_color(self.get_tracker_color(k))
                    self.trackers[k].append((x,y,val))

    @simple_debug
    def remove (self, x, y, do_removal=False):
        """Remove x,y from our visible grid.

        If do_removal, remove it from our underlying grid as well.
        """        
        e=self.__entries__[(x,y)]
        if self.__error_pairs__.has_key((x,y)):
            e.set_error_highlight(False)
            errors_removed = self.__error_pairs__[(x,y)]
            del self.__error_pairs__[(x,y)]
            for coord in errors_removed:
                # If we're not an error by some other pairing...
                if not self.__error_pairs__.has_key((x,y)):
                    linked_entry = self.__entries__[coord]
                    linked_entry.set_error_highlight(False)
                    # Its possible this highlighted error was never
                    # added to our internal grid, in which case we'd
                    # better make sure it is...
                    if not self.grid._get_(linked_entry.x,linked_entry.y):
                        self.add(linked_entry.x,linked_entry.y,linked_entry.get_value()) 
        # remove trackers
        for t in self.trackers_for_point(x,y):
            remove = []
            for crumb in self.trackers[t]:
                if crumb[0]==x and crumb[1]==y:
                    remove.append(crumb)
            for r in remove:
                self.trackers[t].remove(r)
        if e.get_text(): e.set_value(0)
        e.unset_color()
        if do_removal and self.grid:
            self.grid.remove(x,y)

    @simple_debug
    def auto_fill (self):
        changed=self.grid.auto_fill()
        #changed=self.grid.fill_must_fills        
        #changed=self.grid.fill_deterministically()
        retval = []
        for coords,val in changed:
            self.add(coords[0],coords[1],val)            
            retval.append((coords[0],coords[1],val))
            if self.show_impossible_implications:
                self.mark_impossible_implications(*coords)
        if retval: self.auto_fills += 1
        if self.grid.check_for_completeness():
            self.emit('puzzle-finished')
        return retval

    @simple_debug
    def auto_fill_current_entry (self):
        e = self.get_focused_entry()
        filled = self.grid.auto_fill_for_xy(e.x,e.y)
        if filled and filled!=-1:
            self.add(filled[0][0],filled[0][1],filled[1])
    
    @simple_debug
    def mark_impossible_implications (self, x, y):
        implications = self.grid.find_impossible_implications(x,y)
        if implications:
            for x,y in implications:
                self.__entries__[(x,y)].set_impossible(True)
                if not (x,y) in self.impossibilities:
                    self.impossible_hints += 1
        for x,y in self.impossibilities:
            if not (x,y) in implications:
                self.__entries__[(x,y)].set_impossible(False)
        self.impossibilities = implications

    @simple_debug
    def create_tracker (self, identifier=0):
        if not identifier: identifier = 0
        while self.trackers.has_key(identifier): identifier+=1
        self.trackers[identifier]=[]
        #self.__trackers_tracking__[identifier]=True
        return identifier

    def trackers_for_point (self, x, y, val=None):
        if val:
            # if we have a value we can do this a simpler way...
            track_for_point = filter(
                lambda t: (x,y,val) in t[1],
                self.trackers.items()
                )
        else:
            track_for_point = filter(
                lambda tkr: True in [t[0]==x and t[1]==y for t in tkr[1]],
                self.trackers.items())
        return [t[0] for t in track_for_point]

    def get_tracker_color (self, identifier):
        if len(Fonts.colors)>identifier:
            return Fonts.colors[identifier]
        else:
            Fonts.colors.append("#%02x%02x%02x"%(random.randint(0,255),random.randint(0,255),random.randint(0,255)))
            return self.get_tracker_color(identifier)

    @simple_debug
    def toggle_tracker (self, identifier, value):
        """Toggle tracking for tracker identified by identifier."""
        self.__trackers_tracking__[identifier]=value

    def delete_by_tracker (self, identifier):
        """Delete all cells tracked by tracker ID identifer."""
        ret = []
        while self.trackers[identifier]:
            x,y,v = self.trackers[identifier][0]
            ret.append((x,y,v,self.trackers_for_point(x,y,v)))
            self.remove(x,y)
            self.grid.remove(x,y)
        return ret

    def delete_except_for_tracker (self, identifier):
        tracks = self.trackers[identifier]
        removed = []
        for x in range(self.group_size):
            for y in range(self.group_size):
                val = self.grid._get_(x,y)
                if (val
                    and (x,y,val) not in tracks 
                    and not self.grid.virgin._get_(x,y)
                    ):
                    removed.append((x,y,val,self.trackers_for_point(x,y,val)))
                    self.remove(x,y)
                    self.grid.remove(x,y)
        return removed

    def add_tracker (self, x, y, tracker, val=None):
        self.__entries__[(x,y)].set_color(self.get_tracker_color(tracker))
        if not val: val = self.grid._get_(x,y)
        self.trackers[tracker].append((x,y,val))

    def remove_tracker (self, x, y, tracker, val=None):
        if not val: val = self.grid._get_(x,y)
        self.trackers[tracker].remove((x,y,val))
        
class GridHull (gtk.Alignment):
    def __init__ (self, bg_color, *args, **kwargs):
        self.gsd = SudokuGridDisplay(*args,**kwargs)
        self.eb = gtk.EventBox()
        gtk.Alignment.__init__(self)
        self.inner_align = gtk.Alignment()
        self.eb.add(self.inner_align)
        self.inner_align.add(self.gsd)
        self.add(self.eb)
        self.set_property('xalign',0.5)
        self.set_property('yalign',0.5)
        self.set_border_padding(self.gsd.big_spacing)
        if bg_color: self.set_bg_color(bg_color)
        self.gsd.show()
        self.eb.show()
        self.inner_align.show()

    def set_bg_color (self, color):
        if type(color)==str:
            try: color = gtk.gdk.color_parse(color)
            except: return
        if not color:
            self.eb.modify_bg(gtk.STATE_NORMAL,color)
            self.eb.modify_base(gtk.STATE_NORMAL,color)
            self.eb.modify_fg(gtk.STATE_NORMAL,color)                                    
            for e in self.gsd.__entries__.values():
                e.modify_base_color(None)
        else:
            self.eb.modify_bg(gtk.STATE_NORMAL,color)
            self.eb.modify_base(gtk.STATE_NORMAL,color)
            self.eb.modify_fg(gtk.STATE_NORMAL,color)                        
            for e in self.gsd.__entries__.values():
                e.modify_base_color((entry_color,ro_color))

    def set_border_padding (self, n):
        self.inner_align.set_padding(n,n,n,n)

    def change_font_size (self, size=None, multiplier=None):
        self.gsd.change_font_size(size=size,multiplier=multiplier)
        self.set_border_padding(self.gsd.big_spacing)

if gtk.pygtk_version[1]<8: gobject.type_register(SudokuGridDisplay)

if __name__ == '__main__':
    #eg = EntryGrid()
    size = 9
    gh = GridHull(
        'black',
        grid=sudoku.fiendish_sudoku,
        #grid=sudoku.hard_hex_sudoku,
        group_size=size,
        ); gh.show()
    sg = gh.gsd
    w = gtk.Window()
    vb = gtk.VBox(); vb.show()
    #vb.add(sg)
    vb.add(gh)
    #vb.pack_start(sw,fill=True,expand=True)
    hint = gtk.Label(); hint.show()
    vb.add(hint)
    b = gtk.ToggleButton("Notes"); b.show()
    b.set_active(True)
    db = gtk.SpinButton(); db.show()
    adj=db.get_adjustment()
    adj.lower=0
    adj.upper=25
    adj.step_increment=1
    adj.page_increment=10
    def new_sudoku (*args):
        v=db.get_value()
        sgen = sudoku.SudokuGenerator(group_size=size,
                                      clues=int((size*0.608)**2)
                                      )
        pp=sgen.generate_puzzles(25)
        if len(pp) > v: puz,d=pp[int(v)]
        else: puz,d = pp[-1]
        sg.blank_grid()
        sg.setup_grid(puz.grid,9)
    def test_filler_up (*args):
        sg.blank_grid()
        sg.doing_initial_setup=True
        sg.add(1,2,3)
        sg.add(2,3,4)
        sg.add(3,4,5)
        sg.add(4,5,6)
        sg.doing_initial_setup=False
    sg.label = hint
    b3 = gtk.Button('test'); b3.show()
    b3.connect('clicked',test_filler_up)
    b2 = gtk.Button('Blank'); b2.show()
    b2.connect('clicked',lambda *args: sg.blank_grid())
    def toggle_notes (but,*args):
        if but.get_active(): sg.show_notes()
        else: sg.hide_notes()
    b.connect('clicked',toggle_notes); b.show()
    w.add(vb)
    vb.add(db)
    vb.add(b)
    vb.add(b2)
    vb.add(b3)
    #sg.change_font_size(multiplier=3)
    hb = gtk.HBox(); hb.show()
    vb.add(hb)
    zib = gtk.Button(stock=gtk.STOCK_ZOOM_IN); zib.show()
    zib.connect('clicked',lambda *args: sg.change_font_size(multiplier=1.1))
    zob = gtk.Button(stock=gtk.STOCK_ZOOM_OUT); zob.show()
    zob.connect('clicked',lambda *args: sg.change_font_size(multiplier=0.9))
    hb.add(zib)
    hb.add(zob)
    w.show()
    w.connect('delete-event',lambda *args: gtk.main_quit())
    gtk.main()
